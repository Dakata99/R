[
  {
    "objectID": "text/missing_data.html",
    "href": "text/missing_data.html",
    "title": "The R programming language",
    "section": "",
    "text": "x <- c(1, 2, NA, 3, NA, 4); x\n## [1]  1  2 NA  3 NA  4\nis.na(x)\n## [1] FALSE FALSE  TRUE FALSE  TRUE FALSE\nsum(x)\n## [1] NA\n\nSum of the vector elements excluding NA values:\n\nsum(x, na.rm = TRUE)\n## [1] 10\n\n\n\n\n\ny <- c(1, NULL, 2); y\n## [1] 1 2\nis.null(y)\n## [1] FALSE\nlength(y)\n## [1] 2\n\n\n\n\nNaN and Inf values arise from arithmetic operations that are not defined.\n\n0/0\n## [1] NaN\n1/0\n## [1] Inf"
  },
  {
    "objectID": "text/data_structures.html",
    "href": "text/data_structures.html",
    "title": "The R programming language",
    "section": "",
    "text": "Vectors are collections of elements from the same type. They keep track of the order that the data is entered in. Their indexing starts from 1. You can create a vector in R using the combine function c.\n\nx <- c(1, 2, 3); x\n## [1] 1 2 3\ny <- c(4, 5, 6, 7, 8, 9, 10); y\n## [1]  4  5  6  7  8  9 10\nz <- c(FALSE, TRUE); z\n## [1] FALSE  TRUE\nstr <- c(\"e\", \"x\", \"a\", \"m\", \"p\", \"l\", \"e\"); str\n## [1] \"e\" \"x\" \"a\" \"m\" \"p\" \"l\" \"e\"\n\nNote that the vector has a type and can only store data from one type.\n\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(z)\n## [1] \"logical\"\ntypeof(str)\n## [1] \"character\"\ntypeof(pi)\n## [1] \"double\"\np <- c(5, 6.4, \"string\"); p\n## [1] \"5\"      \"6.4\"    \"string\"\ntypeof(p)\n## [1] \"character\"\n\nNote that in such situations, R will convert the element types to the highest common type following the order\nNULL < logical < integer < double < character\nR is a vectorized language, so operations are applied to each element of the vector automatically, without the need to loop through the vector.\n\nx <- c(1, 2, 3); x\n## [1] 1 2 3\nx + 2\n## [1] 3 4 5\n5 * x\n## [1]  5 10 15\nx^2\n## [1] 1 4 9\nsqrt(x)\n## [1] 1.000000 1.414214 1.732051\n\nWe also has a reduction functions length, sum that reduce down to a number.\n\nlength(x)\n## [1] 3\nsum(x)\n## [1] 6\n\nOperations on vectors with the same length.\n\nx <- c(1, 2, 3)\ny <- c(5, 6, 7)\nx + y\n## [1]  6  8 10\ny - x\n## [1] 4 4 4\nx * y\n## [1]  5 12 21\nx / y\n## [1] 0.2000000 0.3333333 0.4285714\n\nIf the two vectors are with different length, to make the operation we repeat the elements of the shorter vector until the vectors has the same length and then perform the operation.\n\nx <- c(1, 2, 3)\ny <- c(5, 6, 7, 8, 9, 10)\nx + y \n## [1]  6  8 10  9 11 13\ny - x\n## [1] 4 4 4 7 7 7\nx * y\n## [1]  5 12 21  8 18 30\nx / y\n## [1] 0.2000000 0.3333333 0.4285714 0.1250000 0.2222222 0.3000000\n\nTaking elements from the vector:\n\ny <- c(5, 6, 7, 8, 9, 10)\ny[3]\n## [1] 7\ny[c(3, 4)]\n## [1] 7 8\ny[c(4, 2, 3)]\n## [1] 8 6 7\ny[-3]\n## [1]  5  6  8  9 10\ny[8]\n## [1] NA\n\nYou can also assign value to a specific index:\n\ny[9] <- 11\ny\n## [1]  5  6  7  8  9 10 NA NA 11\n\nIf the right-hand side has fewer elements than the data vector referred on the left-hand side, R will recycle the value on the right-hand side. This makes it easy to assign many values at once.\n\ny[10:15] <- 3\ny\n##  [1]  5  6  7  8  9 10 NA NA 11  3  3  3  3  3  3\n\nIndexing by 0 returns a 0-length data vector.\n\ny[0]\n## numeric(0)\n\nIf no indexing is specified, the entire data vector is returned.\n\ny[]\n##  [1]  5  6  7  8  9 10 NA NA 11  3  3  3  3  3  3\n\nDifferent ways to generate vectors:\n\n1:12\n##  [1]  1  2  3  4  5  6  7  8  9 10 11 12\n1:-9\n##  [1]  1  0 -1 -2 -3 -4 -5 -6 -7 -8 -9\nseq(1, 17, by = 2)\n## [1]  1  3  5  7  9 11 13 15 17\nseq(0, 100, length.out = 5)\n## [1]   0  25  50  75 100\nrep(1:3, times = 2)\n## [1] 1 2 3 1 2 3\nrep(1:3, times = 3:1)\n## [1] 1 1 1 2 2 3\nrep(1:3, each = 2)\n## [1] 1 1 2 2 3 3\nrep(1:3, each = 2, times = 2)\n##  [1] 1 1 2 2 3 3 1 1 2 2 3 3\n\n\n\n\nx <- 5:7; x\n## [1] 5 6 7\ny <- 2:5; y\n## [1] 2 3 4 5\ny <= 3\n## [1]  TRUE  TRUE FALSE FALSE\nx[y <= 3]\n## [1] 5 6\nsum(y <= 3)\n## [1] 2\nsum(x[y <= 3])\n## [1] 11\nwhich(y >= 3)\n## [1] 2 3 4\nx[which(y >= 3)]\n## [1]  6  7 NA\nz <- 5:21; z\n##  [1]  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21\nz[y <= 3] # Different vectors length!!!\n## [1]  5  6  9 10 13 14 17 18 21\n\nWe can also have named vectors.\n\ntestScores <- c(Sophia = 73, Olivia = 87, Bob = 72, Liam = 99)\ntestScores\n## Sophia Olivia    Bob   Liam \n##     73     87     72     99\n\nWe can change the names of the students, with their surnames using the names function\n\nnames(testScores) <- c(\"Brown\", \"Grant\", \"Johnson\", \"Smith\")\ntestScores\n##   Brown   Grant Johnson   Smith \n##      73      87      72      99\n\nor with their full names using the setNames function\n\ntestScores <- setNames(c(73, 87, 72, 99), c(\"Sophia Brown\", \"Olivia Grant\", \"Bob Johnson\", \"Liam Smith\"))\ntestScores\n## Sophia Brown Olivia Grant  Bob Johnson   Liam Smith \n##           73           87           72           99\n\nWe can see only the names\n\nnames(testScores)\n## [1] \"Sophia Brown\" \"Olivia Grant\" \"Bob Johnson\"  \"Liam Smith\"\n\nAs you already see their are several functions which take on two forms, one to “get”(names) and one to “set”(names<-) values.\nFor example precip data set lists the average rainfall in inches for 70 cities in the United States. We can see the rainfall in “Los Angeles”\n\nprecip[\"Los Angeles\"]\n## Los Angeles \n##          14\nhead(precip)\n##      Mobile      Juneau     Phoenix Little Rock Los Angeles  Sacramento \n##        67.0        54.7         7.0        48.5        14.0        17.2\ntail(precip)\n## Seattle Tacoma        Spokane     Charleston      Milwaukee       Cheyenne \n##           38.8           17.4           40.8           29.1           14.6 \n##       San Juan \n##           59.2\n\nWe can sort them:\n\nhead(sort(precip), n = 15)\n##        Phoenix           Reno    Albuquerque        El Paso          Boise \n##            7.0            7.2            7.8            7.8           11.5 \n##         Denver    Los Angeles       Cheyenne    Great Falls Salt Lake City \n##           13.0           14.0           14.6           15.0           15.2 \n##        Bismark     Sacramento        Spokane  San Francisco       Honolulu \n##           16.2           17.2           17.4           20.7           22.9\nhead(sort(precip, decreasing = TRUE), n = 15)\n##        Mobile         Miami      San Juan   New Orleans        Juneau \n##          67.0          59.8          59.2          56.8          54.7 \n##  Jacksonville       Jackson       Memphis   Little Rock       Atlanta \n##          54.5          49.2          49.1          48.5          48.3 \n##       Houston      Columbia     Nashville Atlantic City       Norfolk \n##          48.2          46.4          46.0          45.5          44.7\n\n\n\n\n\nLists are ordered sets of components stored in a vector. The objects in the list are not necessarily from the same type, the same data structure or the same length. To create a list in R we use the function list.\n> x <- list(1, 2, 3); x\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n> y <- list(a = 1, b = 2, c = 3); y\n$a\n[1] 1\n\n$b\n[1] 2\n\n$c\n[1] 3\n> z <- list(a = c(1, 2, 4, 5),\n+          b = c(TRUE, FALSE, TRUE),\n+          c = c(\"Statistics\")); z\n$a\n[1] 1 2 4 5\n\n$b\n[1]  TRUE FALSE  TRUE\n\n$c\n[1] \"Statistics\"\n> p <- list(a = c(1, 2, 4, 5),\n+          b = list(c = c(TRUE, FALSE),\n+                   d = c(1, 2, 4),\n+                   e = c(\"string\")),\n+          c = data.frame(x = 1:10, y = rep(c(TRUE, FALSE), 5))); p\n$a\n[1] 1 2 4 5\n\n$b\n$b$c\n[1]  TRUE FALSE\n\n$b$d\n[1] 1 2 4\n\n$b$e\n[1] \"string\"\n\n\n$c\n    x     y\n1   1  TRUE\n2   2 FALSE\n3   3  TRUE\n4   4 FALSE\n5   5  TRUE\n6   6 FALSE\n7   7  TRUE\n8   8 FALSE\n9   9  TRUE\n10 10 FALSE\nWe can see each component’s structure using the str function:\n> str(p)\nList of 3\n $ a: num [1:4] 1 2 4 5\n $ b:List of 3\n  ..$ c: logi [1:2] TRUE FALSE\n  ..$ d: num [1:3] 1 2 4\n  ..$ e: chr \"string\"\n $ c:'data.frame':  10 obs. of  2 variables:\n  ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10\n  ..$ y: logi [1:10] TRUE FALSE TRUE FALSE TRUE FALSE ...\nEach component from the list can be extracted using the $ sign followed by the component’s name or [[<index>]]\n> p$a\n[1] 1 2 4 5\n> p[[1]]\n[1] 1 2 4 5\n> p$b$c\n[1]  TRUE FALSE\n> p[[2]][[1]]\n[1]  TRUE FALSE\nWe can list the names of the components in the list using names function\n> names(p)\n[1] \"a\" \"b\" \"c\"\n> names(p$b)\n[1] \"c\" \"d\" \"e\"\n\n\nMatrix\n\nAll of the elements in a matrix must be of the same type. To create a matrix in R we use the function matrix.\n> A <- matrix(c(2, 4, 1, 5, 7, 6),\n+            nrow = 2,\n+            ncol = 3)\n> A\n     [,1] [,2] [,3]\n[1,]    2    1    7\n[2,]    4    5    6\n> A <- matrix(c(2, 4, 1, 5, 7, 6),\n+            nrow = 2,\n+            ncol = 3,\n+            byrow = TRUE)\n> A\n     [,1] [,2] [,3]\n[1,]    2    4    1\n[2,]    5    7    6\n> B <- matrix(c(2, 4, 3, 1, 5, 7),\n+            nrow = 3,\n+            ncol = 2)\n> B\n     [,1] [,2]\n[1,]    2    1\n[2,]    4    5\n[3,]    3    7\nDimensions of the matrix\n> dim(B)\n[1] 3 2\nTaking elements of the matrix:\n> A[2, 3]\n[1] 6\n> A[2, ]\n[1] 5 7 6\n> A[, 3]\n[1] 1 6\n> A[, c(1, 3)]\n     [,1] [,2]\n[1,]    2    1\n[2,]    5    6\nOperations on matrices:\n> A\n     [,1] [,2] [,3]\n[1,]    2    4    1\n[2,]    5    7    6\n> A + 3\n     [,1] [,2] [,3]\n[1,]    5    7    4\n[2,]    8   10    9\n> G <- matrix(rep(1:2, times=3), nrow = 2); G\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    2    2    2\n> A + G\n     [,1] [,2] [,3]\n[1,]    3    5    2\n[2,]    7    9    8\n> A*G\n     [,1] [,2] [,3]\n[1,]    2    4    1\n[2,]   10   14   12\nt transpose the matrix:\n> t(A)\n     [,1] [,2]\n[1,]    2    5\n[2,]    4    7\n[3,]    1    6\n%*% algebraic multiplication of two matrices\n> G %*% t(A)\n     [,1] [,2]\n[1,]    7   18\n[2,]   14   36\ncbind combine a sequence of vector, matrix or data frame by columns\n> cbind(c(1, 2, 3), c(3, 4, 5))\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n[3,]    3    5\n> cbind(B, c(3, 4, 5))\n     [,1] [,2] [,3]\n[1,]    2    1    3\n[2,]    4    5    4\n[3,]    3    7    5\nrbind combine a sequence of vector, matrix or data frame by rows\n> rbind(c(1, 2, 3), c(3, 4, 5))\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    3    4    5\n> C <- rbind(A, c(3, 4, 5)); C\n     [,1] [,2] [,3]\n[1,]    2    4    1\n[2,]    5    7    6\n[3,]    3    4    5\ndimnames set names to the dimensions of the object\n> dimnames(C) <- list(c(\"r1\", \"r2\", \"r3\"), c(\"c1\", \"c2\", \"c3\"))\n> C\n   c1 c2 c3\nr1  2  4  1\nr2  5  7  6\nr3  3  4  5\nYou can also use colnames and rownames functions to set the names of the object\n> colnames(C) <- c(\"col1\", \"col2\", \"col3\")\n> C\n   col1 col2 col3\nr1    2    4    1\nr2    5    7    6\nr3    3    4    5\n> rownames(C) <- c(\"row1\", \"row2\", \"row3\")\n> C\n     col1 col2 col3\nrow1    2    4    1\nrow2    5    7    6\nrow3    3    4    5\n\n\n\nArrays\n\nArrays are multidimensional vectors. All the elements in the array must be of the same type. To create an array in R we use the function array.\n> x <- array(1:24, dim = c(4, 3, 2)); x\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]   13   17   21\n[2,]   14   18   22\n[3,]   15   19   23\n[4,]   16   20   24\nTaking elements of the array\n> x[1, , ]\n     [,1] [,2]\n[1,]    1   13\n[2,]    5   17\n[3,]    9   21\n> x[1, , 1]\n[1] 1 5 9\n> x[, , 1]\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\ndimnames set names to the dimensions of the object\n> dimnames(x) <- list(c(\"x1\", \"x2\", \"x3\", \"x4\"), c(\"y1\", \"y2\", \"y3\"), c(\"z1\", \"z2\"))\n> x\n, , z1\n\n   y1 y2 y3\nx1  1  5  9\nx2  2  6 10\nx3  3  7 11\nx4  4  8 12\n\n, , z2\n\n   y1 y2 y3\nx1 13 17 21\nx2 14 18 22\nx3 15 19 23\nx4 16 20 24\n\n\n\nData frames\n\nData frames hold vectors not necessarily from the same type but with the same length. To create a data frame in R we use the function data.frame.\n> first <- 1:10 \n> second <- c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\", \"gg\", \"hh\", \"ii\", \"jj\") \n> third <- c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE) \n> df <- data.frame(first, second, third); df\n   first second third\n1      1     aa  TRUE\n2      2     bb FALSE\n3      3     cc  TRUE\n4      4     dd  TRUE\n5      5     ee FALSE\n6      6     ff  TRUE\n7      7     gg FALSE\n8      8     hh FALSE\n9      9     ii  TRUE\n10    10     jj FALSE\n> class(df)\n[1] \"data.frame\"\nYou can use View function to visualize the data frame in a separate window.\nhead and tail visualize the first 6 respectively the last 6 set of rows of the data frame\n> head(df)\n  first second third\n1     1     aa  TRUE\n2     2     bb FALSE\n3     3     cc  TRUE\n4     4     dd  TRUE\n5     5     ee FALSE\n6     6     ff  TRUE\n> tail(df)\n   first second third\n5      5     ee FALSE\n6      6     ff  TRUE\n7      7     gg FALSE\n8      8     hh FALSE\n9      9     ii  TRUE\n10    10     jj FALSE\nWe can change this for example to the first 3 respectively the last 3 set of rows of the data frame\n> head(df, n = 3)\n  first second third\n1     1     aa  TRUE\n2     2     bb FALSE\n3     3     cc  TRUE\n> tail(df, n = 3)\n   first second third\n8      8     hh FALSE\n9      9     ii  TRUE\n10    10     jj FALSE\ndim, nrow and ncol shows the dimensions of the data frame\n> dim(df)\n[1] 10  3\n> dim(df)[1]\n[1] 10\n> dim(df)[2]\n[1] 3\n> nrow(df)\n[1] 10\n> ncol(df)\n[1] 3\nTo view the data types of the columns we can use the str function\n> str(df)\n'data.frame':   10 obs. of  3 variables:\n $ first : int  1 2 3 4 5 6 7 8 9 10\n $ second: chr  \"aa\" \"bb\" \"cc\" \"dd\" ...\n $ third : logi  TRUE FALSE TRUE TRUE FALSE TRUE ...\nIt is possible to give or change the names of the columns of the data frame\n> df <- data.frame(A = first, B = second, C = third); df\n    A  B     C\n1   1 aa  TRUE\n2   2 bb FALSE\n3   3 cc  TRUE\n4   4 dd  TRUE\n5   5 ee FALSE\n6   6 ff  TRUE\n7   7 gg FALSE\n8   8 hh FALSE\n9   9 ii  TRUE\n10 10 jj FALSE\nnames shows the names of the columns of the data frame\n> names(df)\n[1] \"A\" \"B\" \"C\"\nYou can give names to the rows and columns of the data frame using the colnames and rownames functions\n> colnames(df) <- c(\"f\", \"s\", \"t\"); df\n    f  s     t\n1   1 aa  TRUE\n2   2 bb FALSE\n3   3 cc  TRUE\n4   4 dd  TRUE\n5   5 ee FALSE\n6   6 ff  TRUE\n7   7 gg FALSE\n8   8 hh FALSE\n9   9 ii  TRUE\n10 10 jj FALSE\n> rownames(df) <- c(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\"); df\n       f  s     t\none    1 aa  TRUE\ntwo    2 bb FALSE\nthree  3 cc  TRUE\nfour   4 dd  TRUE\nfive   5 ee FALSE\nsix    6 ff  TRUE\nseven  7 gg FALSE\neight  8 hh FALSE\nnine   9 ii  TRUE\nten   10 jj FALSE\nor we can use predefined constants for the names\n> colnames(df) <- LETTERS[1:3]; df\n       A  B     C\none    1 aa  TRUE\ntwo    2 bb FALSE\nthree  3 cc  TRUE\nfour   4 dd  TRUE\nfive   5 ee FALSE\nsix    6 ff  TRUE\nseven  7 gg FALSE\neight  8 hh FALSE\nnine   9 ii  TRUE\nten   10 jj FALSE\n> rownames(df) <- month.name[1:10]; df\n           A  B     C\nJanuary    1 aa  TRUE\nFebruary   2 bb FALSE\nMarch      3 cc  TRUE\nApril      4 dd  TRUE\nMay        5 ee FALSE\nJune       6 ff  TRUE\nJuly       7 gg FALSE\nAugust     8 hh FALSE\nSeptember  9 ii  TRUE\nOctober   10 jj FALSE\nData frame attributes: names lists the names of the columns and row.names lists the names of the rows.\n> attributes(df)\n$names\n[1] \"A\" \"B\" \"C\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"  \n> names(df)\n[1] \"A\" \"B\" \"C\"\n> colnames(df)\n[1] \"A\" \"B\" \"C\"\n> rownames(df)\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"\nTaking elements of a data frame\nTaking the element from the 2 row, 3 column\n> df[2, 3]\n[1] FALSE\nTaking the elements from the 2 row\n> df[2, ]\n         A  B     C\nFebruary 2 bb FALSE\nTaking the elements from the 3 column\n> df[, 3]\n [1]  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE\nTaking the elements from the 2 row, 2 and 3 columns\n> df[2, 2:3]\n          B     C\nFebruary bb FALSE\nTaking the elements from the 2 row, columns “A” and “B”\n> df[2, c(\"A\" , \"B\")]\n         A  B\nFebruary 2 bb\nTaking the elements from the column “A”\n> df$A\n [1]  1  2  3  4  5  6  7  8  9 10\nTaking the elements from the 2 column\n> df[[2]]\n [1] \"aa\" \"bb\" \"cc\" \"dd\" \"ee\" \"ff\" \"gg\" \"hh\" \"ii\" \"jj\"\n\n\n\nAdditional notes\n\n\nFor execution on Linux (in terminal): Rscript main.R"
  },
  {
    "objectID": "text/overview.html",
    "href": "text/overview.html",
    "title": "The R programming language",
    "section": "",
    "text": "R\ncmake –build ./build/ –target display_documentation\n\nprint(\"HELLO\")\n\nHELLO"
  },
  {
    "objectID": "text/reading_data.html",
    "href": "text/reading_data.html",
    "title": "The R programming language",
    "section": "",
    "text": "scan() function will scan the keyboard until an empty line is specified.\nIf the file that you are going to read is saved in your working directory, you do not need to specify the whole path to the file or you can use file.choose function.\n\n\n\nGetting help\n\n?read.table\n\nread.table reads a file and creates a data frame from it. By default it doesn’t have a header.\n\nourData <- read.table(\"./data.txt\", header = TRUE, sep=\"\")\nhead(ourData)\n\n\n\n\nGetting help\n\n?read.csv\n\ncsv stands for comma-separated values. read.csv reads a file and creates a data frame from it. By default it has a header and the values are separated sep by ,."
  },
  {
    "objectID": "text/data_types.html",
    "href": "text/data_types.html",
    "title": "The R programming language",
    "section": "",
    "text": "Basic Data Types\n\nYou can get an object’s type using the typeof function.\nis.() checks the  of the object\nas.() converts the object to \n\n\n\nLogical\n\nLogical values can take one of two values: TRUE or FALSE. They can also be represented as T and F. But be careful, because these values can be overwritten.\nWhere True is the same as 1 and False is the same as 0.\n> x <- 1\n> y <- 2\n> z <- x > y\ntypeof function prints the type of the object\n> typeof(z)\n[1] \"logical\"\n**is.logical checks if the class type of the object is logical\n> is.logical(2.5)\n[1] FALSE\n> is.logical(y)\n[1] FALSE\n> is.logical(z)\n[1] TRUE\n> is(z, \"logical\")\n[1] TRUE\nas.logical converts the type of the object to logical one\n> x <- as.logical(10.5); x; typeof(x)\n[1] TRUE\n[1] \"logical\"\n> x <- as.logical(1); x; typeof(x)\n[1] TRUE\n[1] \"logical\"\n> x <- as.logical(0); x; typeof(x)\n[1] FALSE\n[1] \"logical\"\n> x <- as.logical(\"string\"); x; typeof(x)\n[1] NA\n[1] \"logical\"\nSome more examples:\n> FALSE < TRUE\n[1] TRUE\n> 5 * TRUE\n[1] 5\n> NA != NA\n[1] NA\n> NA == NA # Use is.na(NA) to check if an object is NA\n[1] NA\n> 2 < Inf\n[1] TRUE\n> Inf == Inf\n[1] TRUE\n> -Inf < Inf\n[1] TRUE\n> NA < Inf\n[1] NA\nStrings are compared lexicographically\n> \"data\" == \"statistics\"\n[1] FALSE\n> \"data\" < \"math\"\n[1] TRUE\nYou can also use the functions any, all and which\n> v <- c(FALSE, FALSE, TRUE, FALSE)\n> any(v)\n[1] TRUE\n> which(v)\n[1] 3\n> v <- c(TRUE, TRUE, TRUE, TRUE)\n> all(v)\n[1] TRUE\n%in% function tests whether an element is in a collection and match return their indexes in the collection\n> v <- c(36, 45, 23, 17, 64, 75)\n> 17 %in% v\n[1] TRUE\n> match(17, v)\n[1] 4\n> c(17, 45, 12) %in% v\n[1]  TRUE  TRUE FALSE\n> match(c(17, 45, 12), v)\n[1]  4  2 NA\n\n\n\nInteger\n\nIf you want variable’s type to be integer, you must set it explicitly.\n> x <- 3; x\n[1] 3\n> typeof(x)\n[1] \"double\"\n> is.integer(x)\n[1] FALSE\nWe can define it as integer in one of the following ways:\n> y <- as.integer(12.35); y \n[1] 12\n> typeof(y)\n[1] \"integer\"\n> z <- 3L; z\n[1] 3\n> typeof(z)\n[1] \"integer\"\nSome more examples:\n> typeof(4L * 2)\n[1] \"double\"\n> typeof(4L * 2L)\n[1] \"integer\"\n> typeof(6L / 2L)\n[1] \"double\"\nIntegers have a limited range, roughly between −2∗109,2∗109. You can see ?.Machine for more information\n> .Machine$integer.max\n[1] 2147483647\n> as.integer(2147483647)\n[1] 2147483647\n> as.integer(2147483648)\nWarning: NAs introduced by coercion to integer range\n[1] NA\n\n\n\nDouble\n\nIt describes all the real numbers.\n> k <- 1; k\n[1] 1\n> typeof(k)\n[1] \"double\"\n> is.numeric(k)\n[1] TRUE\n> x <- 10.5; x\n[1] 10.5\n> typeof(x)\n[1] \"double\"\nDoubles are able to represent a larger range of integer values, from −2.Machine\\(double.digits,2.Machine\\)double.digits. If you go outside that range, some integers are not exactly representable.\n> .Machine$double.digits\n[1] 53\n> print(max.num <- 2 ^ .Machine$double.digits)\n[1] 9.007199e+15\n> options(digits = 22)\n> print(max.num <- 2 ^ .Machine$double.digits)\n[1] 9007199254740992\n> (max.num) - (max.num - 1)\n[1] 1\n> (max.num + 1) - (max.num)\n[1] 0\n> (max.num + 2) - (max.num + 1)\n[1] 2\n\n\n\nComplex\n\nIt describes the set of complex numbers.\n> z <- 5 + 6i; z\n[1] 5+6i\n> typeof(z)\n[1] \"complex\"\n> is.complex(z)\n[1] TRUE\n> as.complex(4)\n[1] 4+0i\n\n\n\nCharacter\n\n> s <- \"statistics\"; s\n[1] \"statistics\"\n> typeof(s)\n[1] \"character\"\n> is.character(s)\n[1] TRUE\n> as.character(123)\n[1] \"123\"\nSome operations with characters\nnchar gives the number of characters in the string\n> nchar(s)\n[1] 10\nsubstr extract substrings\n> substr(s, start = 1, stop = 4)\n[1] \"stat\"\nIt is worth mеntioning that you can’t concatenate strings with + sign.\n> x <- \"1\"\n> y <- \"3.5\"\n> x + y\nError in x + y: non-numeric argument to binary operator\nWe need to use C-style sprintf formatting\n> sprintf(\"X%s\", 1:3)\n[1] \"X1\" \"X2\" \"X3\"\nor the paste function with parameters sep defining the separator between variables (default is sep=” “) and collapse to combine the elements of the resulting vector with the given delimiter.\n> paste(x, y)\n[1] \"1 3.5\"\n> paste(\"X\", 1:3)\n[1] \"X 1\" \"X 2\" \"X 3\"\n> paste(\"X\", 1:3, sep = \"\")\n[1] \"X1\" \"X2\" \"X3\"\n> paste(\"X\", 1:3, sep = \"\", collapse = \", \")\n[1] \"X1, X2, X3\"\nWhere the function converts the parameters to strings.\n> x <- 1\n> y <- 3.5\n> paste(x, y)\n[1] \"1 3.5\"\nYou can work with regular expressions using grep function. For examples lets look at state.name data (?state) containing the 50 full state names of the United States of America.\n> state.name\n [1] \"Alabama\"        \"Alaska\"         \"Arizona\"        \"Arkansas\"      \n [5] \"California\"     \"Colorado\"       \"Connecticut\"    \"Delaware\"      \n [9] \"Florida\"        \"Georgia\"        \"Hawaii\"         \"Idaho\"         \n[13] \"Illinois\"       \"Indiana\"        \"Iowa\"           \"Kansas\"        \n[17] \"Kentucky\"       \"Louisiana\"      \"Maine\"          \"Maryland\"      \n[21] \"Massachusetts\"  \"Michigan\"       \"Minnesota\"      \"Mississippi\"   \n[25] \"Missouri\"       \"Montana\"        \"Nebraska\"       \"Nevada\"        \n[29] \"New Hampshire\"  \"New Jersey\"     \"New Mexico\"     \"New York\"      \n[33] \"North Carolina\" \"North Dakota\"   \"Ohio\"           \"Oklahoma\"      \n[37] \"Oregon\"         \"Pennsylvania\"   \"Rhode Island\"   \"South Carolina\"\n[41] \"South Dakota\"   \"Tennessee\"      \"Texas\"          \"Utah\"          \n[45] \"Vermont\"        \"Virginia\"       \"Washington\"     \"West Virginia\" \n[49] \"Wisconsin\"      \"Wyoming\"       \nLet’s take the states containing v in their name. Parameter value=TRUE shows the matching elements, otherwise we will see their indexes.\n> grep(pattern = \"v\", state.name, value = TRUE)\n[1] \"Nevada\"       \"Pennsylvania\"\n> grep(pattern = \"v\", state.name)\n[1] 28 38\nIf we want to also see the states containing V we need to add ignore.case=TRUE\n> grep(pattern = \"v\", state.name, ignore.case = TRUE, value = TRUE)\n[1] \"Nevada\"        \"Pennsylvania\"  \"Vermont\"       \"Virginia\"     \n[5] \"West Virginia\"\nAnd for example if we want to see only those names of states starting with V\n> grep(pattern = \"^V\", state.name, value = TRUE)\n[1] \"Vermont\"  \"Virginia\"\n\n\n\nDerived Data Types\nThe data types below are stored as either of the basic data types, but have additional attribute information that allows to be treated in special ways by certain functions in R. These attributes define the object’s class and can be extracted from that object via the class or attribute function.\n\n\nFactor\n\nFactors are used to group variables into a fixed number of unique categories or levels.\nFor example imagine we have some weather sample:\n> weather <- c(\"Sunny\", \"Sunny\", \"Sunny\", \"Cloudy\", \"Sunny\", \"Sunny\", \"Cloudy\",\n+              \"Cloudy\", \"Stormy\", \"Cloudy\", \"Fog\", \"Sunny\", \"Sunny\", \"Cloudy\",\n+              \"Cloudy\", \"Stormy\", \"Cloudy\", \"Fog\", \"Rain\", \"Rain\", \"Snow\", \"Snow\")\n> weather\n [1] \"Sunny\"  \"Sunny\"  \"Sunny\"  \"Cloudy\" \"Sunny\"  \"Sunny\"  \"Cloudy\" \"Cloudy\"\n [9] \"Stormy\" \"Cloudy\" \"Fog\"    \"Sunny\"  \"Sunny\"  \"Cloudy\" \"Cloudy\" \"Stormy\"\n[17] \"Cloudy\" \"Fog\"    \"Rain\"   \"Rain\"   \"Snow\"   \"Snow\"  \nLets convert it to factors. We have the same vector, but now with the unique labels of the categories.\n> factorWeather <- as.factor(weather)\n> factorWeather\n [1] Sunny  Sunny  Sunny  Cloudy Sunny  Sunny  Cloudy Cloudy Stormy Cloudy\n[11] Fog    Sunny  Sunny  Cloudy Cloudy Stormy Cloudy Fog    Rain   Rain  \n[21] Snow   Snow  \nLevels: Cloudy Fog Rain Snow Stormy Sunny\nSo how is this object represented?\nUsing the typeof we can see that the factor is saved in integer format\n> typeof(weather)\n[1] \"character\"\n> typeof(factorWeather)\n[1] \"integer\"\n> as.integer(factorWeather)\n [1] 6 6 6 1 6 6 1 1 5 1 2 6 6 1 1 5 1 2 3 3 4 4\nWhy is it storing the values as integer?\n\nThe reason is the factor objects are storing each value as an integer that points to one of the unique levels.\n\nTheir respective class are:\n> class(weather)\n[1] \"character\"\n> class(factorWeather)\n[1] \"factor\"\nThe factor object has 2 attributes: class and levels. Wherelevels shows all the possible categories for the data in the factor.\n> attributes(factorWeather)\n$levels\n[1] \"Cloudy\" \"Fog\"    \"Rain\"   \"Snow\"   \"Stormy\" \"Sunny\" \n\n$class\n[1] \"factor\"\nWe can also see the unique levels and their order using levels function\n> levels(factorWeather)\n[1] \"Cloudy\" \"Fog\"    \"Rain\"   \"Snow\"   \"Stormy\" \"Sunny\" \nThe order in which the levels are displayed match their integer representation.\nWe can not assign a value into a factor unless it matches a level. Trying to will rise a warning and insert a value of NA\n> factorWeather[23] <- \"Windy\"\nWarning in `[<-.factor`(`*tmp*`, 23, value = \"Windy\"): invalid factor level, NA\ngenerated\n> factorWeather\n [1] Sunny  Sunny  Sunny  Cloudy Sunny  Sunny  Cloudy Cloudy Stormy Cloudy\n[11] Fog    Sunny  Sunny  Cloudy Cloudy Stormy Cloudy Fog    Rain   Rain  \n[21] Snow   Snow   <NA>  \nLevels: Cloudy Fog Rain Snow Stormy Sunny\nFirst we need to add it to the levels of the factor\n> levels(factorWeather) <- c(levels(factorWeather), \"Windy\")\n> factorWeather[23] <- \"Windy\"\n> factorWeather\n [1] Sunny  Sunny  Sunny  Cloudy Sunny  Sunny  Cloudy Cloudy Stormy Cloudy\n[11] Fog    Sunny  Sunny  Cloudy Cloudy Stormy Cloudy Fog    Rain   Rain  \n[21] Snow   Snow   Windy \nLevels: Cloudy Fog Rain Snow Stormy Sunny Windy\nThis will be used when making plots in the next chapter.\n\n\n\nDate\n\nDate, POSIXlt and POSIXct classes represent calendar dates. - as.Date stores just dates using different origins\n> d <- as.Date(\"2019-05-27\"); d\n[1] \"2019-05-27\"\nYou can see that the object is of class Date and its type is double representing the number of dates after the origin.\n> class(d)\n[1] \"Date\"\n> typeof(d)\n[1] \"double\"\n> as.double(d)\n[1] 18043\nDates can be in different format ?parse_date_time, but the output is in ISO 8601 international standard format %Y-%m-%d\n> d <- as.Date(\"05/27/19\", format = \"%m/%d/%y\"); d\n[1] \"2019-05-27\"\n> d <- as.Date(18043, origin = \"1899-12-30\"); d\n[1] \"1949-05-25\"\nas.POSIXct stores data and time as the number of seconds since January 1, 1970\n> t <- as.POSIXct(\"2019-05-27 17:42\"); t\n[1] \"2019-05-27 17:42:00 EEST\"\n> typeof(t)\n[1] \"double\"\n> class(t)\n[1] \"POSIXct\" \"POSIXt\" \n> as.Date(t)\n[1] \"2019-05-27\"\n> attributes(t)\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"\"\nas.POSIXlt stores them as a list with elements for year, month, day, hour, minutes and seconds. We can see this using the function attribute.\n> t <- as.POSIXlt(\"2019-05-27 17:42\"); t\n[1] \"2019-05-27 17:42:00 EEST\"\n> typeof(t)\n[1] \"list\"\n> class(t)\n[1] \"POSIXlt\" \"POSIXt\" \n> as.Date(t)\n[1] \"2019-05-27\"\n> attributes(t)\n$names\n [1] \"sec\"    \"min\"    \"hour\"   \"mday\"   \"mon\"    \"year\"   \"wday\"   \"yday\"  \n [9] \"isdst\"  \"zone\"   \"gmtoff\"\n\n$class\n[1] \"POSIXlt\" \"POSIXt\"\nYou can easily take the year from the list using \\(. It shows the number of years since 1900, so we see 2019 as 119. ``` > t\\)year [1] 119\n\nShows the month in 0−11 format, so we see May as 4.\n\nt$mon [1] 4\n\n\nShows the day in 1−31 format\n\nt$mday [1] 27\n\n\nShows the hours, minutes and seconds\n\nt\\(hour [1] 17 t\\)min [1] 42 t$sec [1] 0 ```"
  },
  {
    "objectID": "text/packages.html",
    "href": "text/packages.html",
    "title": "The R programming language",
    "section": "",
    "text": "R has a rich collection of packages. They allow researchers to share R functions and data. You can install packages available in the CRAN repository using install.packages. We already learned how we can get help\n\n?install.packages\nhelp(\"install.packages\")\n\nYou can also install packages from the R Studio interface\nFor the next tasks you will need to install UsingR and MASS packages available in the CRAN repository.\n\ninstall.packages(\"UsingR\")\n\nInstalling package into '/home/daniel/R/x86_64-pc-linux-gnu-library/4.1'\n(as 'lib' is unspecified)\n\n\nWarning: unable to access index for repository https://cloud.r-project.org/src/contrib:\n  cannot open URL 'https://cloud.r-project.org/src/contrib/PACKAGES'\n\n\nWarning: package 'UsingR' is not available for this version of R\n\nA version of this package for your version of R might be available elsewhere,\nsee the ideas at\nhttps://cran.r-project.org/doc/manuals/r-patched/R-admin.html#Installing-packages\n\ninstall.packages(\"MASS\")\n\nInstalling package into '/home/daniel/R/x86_64-pc-linux-gnu-library/4.1'\n(as 'lib' is unspecified)\n\n\nWarning: unable to access index for repository https://cloud.r-project.org/src/contrib:\n  cannot open URL 'https://cloud.r-project.org/src/contrib/PACKAGES'\n\n\nWarning: package 'MASS' is not available for this version of R\n\nA version of this package for your version of R might be available elsewhere,\nsee the ideas at\nhttps://cran.r-project.org/doc/manuals/r-patched/R-admin.html#Installing-packages\n\n\nWe can also install packages from GitHub using install_github. But first you need to install devtools from CRAN.\nYou can also see available packages using the available.packages or update a package using update.packages functions.\n\n\n\nJust because a package is installed on your computer does not mean that you have access to its functions. We need to load the package into the current R session. Getting help\n\n?library\n\nLoad the package in the memory\n\nlibrary(UsingR)\n\nLoading required package: MASS\n\n\nLoading required package: HistData\n\n\nLoading required package: Hmisc\n\n\nLoading required package: lattice\n\n\nLoading required package: survival\n\n\nLoading required package: Formula\n\n\nLoading required package: ggplot2\n\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\n\n\nAttaching package: 'UsingR'\n\n\nThe following object is masked from 'package:survival':\n\n    cancer\n\nlibrary(MASS)\n\nIn R we have Warning and Error messages. Warning messages do not stop the flow of the function.\nYou can also use the require function to load a package.\n\n\n\nYou can see information about your current session - R version, OS, attached or loaded packages and their versions using sessionInfo.\n\nsessionInfo()\n\nR version 4.1.3 (2022-03-10)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.1 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=bg_BG.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=bg_BG.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=bg_BG.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=bg_BG.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] UsingR_2.0-7    Hmisc_4.6-0     ggplot2_3.3.5   Formula_1.2-4  \n[5] survival_3.2-13 lattice_0.20-45 HistData_0.8-7  MASS_7.3-56    \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.1.2    xfun_0.30           purrr_0.3.4        \n [4] splines_4.1.3       colorspace_2.0-3    vctrs_0.4.0        \n [7] generics_0.1.2      htmltools_0.5.2     yaml_2.3.5         \n[10] base64enc_0.1-3     utf8_1.2.2          rlang_1.0.2        \n[13] pillar_1.7.0        foreign_0.8-82      glue_1.6.2         \n[16] withr_2.5.0         RColorBrewer_1.1-3  jpeg_0.1-9         \n[19] lifecycle_1.0.1     stringr_1.4.0       munsell_0.5.0      \n[22] gtable_0.3.0        htmlwidgets_1.5.4   evaluate_0.15      \n[25] latticeExtra_0.6-29 knitr_1.38          fastmap_1.1.0      \n[28] fansi_1.0.3         htmlTable_2.4.0     backports_1.4.1    \n[31] checkmate_2.0.0     scales_1.1.1        jsonlite_1.8.0     \n[34] gridExtra_2.3       png_0.1-7           digest_0.6.29      \n[37] stringi_1.7.6       dplyr_1.0.8         grid_4.1.3         \n[40] cli_3.2.0           tools_4.1.3         magrittr_2.0.3     \n[43] tibble_3.1.6        cluster_2.1.3       crayon_1.5.1       \n[46] pkgconfig_2.0.3     ellipsis_0.3.2      Matrix_1.4-1       \n[49] data.table_1.14.2   rstudioapi_0.13     rmarkdown_2.13     \n[52] rpart_4.1.16        R6_2.5.1            nnet_7.3-17        \n[55] compiler_4.1.3     \n\n\n\n\n\nSometimes you need to unload a package.\ndetach(\"package:MASS\")\n\n\n\nremove.packages remove installed packages.\n\nremove.packages(\"MASS\")\n\n\n\n\nNext are considered examples with mtcars data frame from datasets package.\n\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nWring ? before the name of the data frame gives information about the data frame, if it is available.\n\n?mtcars\n\nYou can see what is this data frame about and some information about the data contained in the columns.\nAs we already saw we can use dim,nrow and ncol to show the dimensions of the data frame\n\ndim(mtcars)\n\n[1] 32 11\n\nnrow(mtcars)\n\n[1] 32\n\nncol(mtcars)\n\n[1] 11\n\n\nNext different ways to take only part of the data frame are reviewed. Shows the element in the 1 row, 2 column\n\nmtcars[1, 2]\n\n[1] 6\n\n\nShows the element in the “Mazda RX4” row, “cyl” column\n\nmtcars[\"Mazda RX4\", \"cyl\"]\n\n[1] 6\n\n\nShows the elements in the 9 column\n\nmtcars[[9]]\n\n [1] 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1\n\n\nShows the element in the “am” column\n\nmtcars[[\"am\"]]\n\n [1] 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1\n\n\nShows the element in the “am” column\n\nmtcars$am\n\n [1] 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1\n\n\n\n\n\nTaking the names of the columns in the data frame\n\nnames(mtcars)\n\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n\n\nLet’s say we want to take the mpg column, we can use $ after the data frame’s name\n\nmtcars$mpg\n\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n\n\nor to attach the data frame and only to write the name of the column.\n\nattach(mtcars)\n\nThe following object is masked from package:ggplot2:\n\n    mpg\n\nmpg\n\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n\n\nattach loads the data frame, so it is not necessary to write the data frame’s name in front of the column name. Getting help\n\n?attach\n\nSometime this is very helpful, but it is important to notice that if you change the attached object the data frame is not going to change. For example let’s change the first value\n\nmpg[1] = 200\nmpg\n\n [1] 200.0  21.0  22.8  21.4  18.7  18.1  14.3  24.4  22.8  19.2  17.8  16.4\n[13]  17.3  15.2  10.4  10.4  14.7  32.4  30.4  33.9  21.5  15.5  15.2  13.3\n[25]  19.2  27.3  26.0  30.4  15.8  19.7  15.0  21.4\n\nmtcars$mpg\n\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4"
  },
  {
    "objectID": "text/statistics.html",
    "href": "text/statistics.html",
    "title": "The R programming language",
    "section": "",
    "text": "Descriptive Statistics /Описателни статистики/\nPopulation /Популация/ Total set of observations that can be made.\nPopulation sample /Извадка/ A sample is a random selection of population members. It is a small group drawn from the population that has the characteristics of the entire population. It can be with or without replacement.\nExample: Let’s say we want to measure the content of vitamin C in the kiwi. We can’t take all the kiwis and measure their vitamin C, so we make a population sample of 30 kiwis and measure their vitamin C.\nLet’s denote with: X a random variable measuring the vitamin C in 100g of kiwi. Let’s make 30 experiments, so our sample size n will be 30. And every one of our experiments will consist of taking 100g of kiwi and measuring the vitamin C in it, so this will be our sample x1,x2,…,x30.\nLet’s say our sample looks like this:\n\nvitamin <- c(91.66, 92.34, 92.69, 92.97, 93.40, 92.94, 92.76, 92.39, 93.74, 91.77, 92.09, + 92.99, 93.13, 92.73, 92.81, 93.39, 93.29, 93.03, 93.13, 92.08, 93.27, 92.82, + 92.99, 92.60, 93.41, 92.89, 92.76, 92.19, 92.34, 92.68) Order statistics /Вариационен ред/ Order statistics present the sample data in a sorted way. They are denoted by x(1)≤x(2)≤…≤x(n), where x(1) is the smallest observation in the sample and x(n) is the biggest observation in the sample.\n\n\nsort(vitamin) [1] 91.66 91.77 92.08 92.09 92.19 92.34 92.34 92.39 92.60 92.68 92.69 92.73 [13] 92.76 92.76 92.81 92.82 92.89 92.94 92.97 92.99 92.99 93.03 93.13 93.13 [25] 93.27 93.29 93.39 93.40 93.41 93.74 One more example:\n\n\nx <- c(10, 3, 4, 7, 34, 23); x [1] 10 3 4 7 34 23 sort sorts the vector in ascending order by default\n\n\nsort(x) [1] 3 4 7 10 23 34 sort(x, decreasing = TRUE) [1] 34 23 10 7 4 3 Rank /Ранг/ Ranks are the places of the elements in the order statistics. Rank(x(i))=i We can take the ranks of the elements using the rank function, which gives the respective rank of the number present in the vector, where the smallest number receives the rank 1.\n\n\nrank(x) [1] 4 1 2 3 6 5 When we have equal elements in the vector by default we are taking the average of their ranks. You can change this to take the smallest, biggest or the rank by occurrence of the equal elements using ties.method.\n\n\ny <- c(x, 10); y [1] 10 3 4 7 34 23 10 rank(y) [1] 4.5 1.0 2.0 3.0 7.0 6.0 4.5 y <- c(y, 10) rank(y) [1] 5 1 2 3 8 7 5 5 rank(y, ties.method = “average”) [1] 5 1 2 3 8 7 5 5 rank(y, ties.method = “min”) [1] 4 1 2 3 8 7 4 4 rank(y, ties.method = “max”) [1] 6 1 2 3 8 7 6 6 rank(y, ties.method = “first”) [1] 4 1 2 3 8 7 5 6 Order order returns the indices of the elements that we have to take to have the sorted vector\n\n\norder(x) [1] 2 3 4 1 6 5 This means that if you take the elements of the vector in this order x[2]=3,x[3]=4,x[4]=7,x[1]=10,x[6]=23,x[5]=34 you will receive the sorted array\n\n\nx[order(x)] [1] 3 4 7 10 23 34 Similarly if we have repeating elements.\n\n\norder(y) [1] 2 3 4 1 7 8 6 5 y[order(y)] [1] 3 4 7 10 10 10 23 34 Minimal observation min returns the smallest observation x(1)\n\n\nmin(vitamin) [1] 91.66 Maximal observation max returns the largest observation x(n)\n\n\nmax(vitamin) [1] 93.74 Sample range /Обхват/ Sample range is the spread (distance) from the biggest to the smallest value in the sample x(n)−x(1). We can make it using directly the formula\n\n\nmax(vitamin)-min(vitamin) [1] 2.08 or we can use function rangeto give us the smallest and the biggest observation and then to compute their difference with diff\n\n\nrange(vitamin) [1] 91.66 93.74 diff(range(vitamin)) [1] 2.08 Sample mean /Извадково средно/ Sample mean is the arithmetic average of all of the sample values. X¯=1n∑i=1nxi=x1+x2+…+xnn\n\n\nmean(vitamin) [1] 92.776 Sample mean estimates the mean of the population.\n\nAnother way to calculate the sample mean is by using the formula\n\nsum(vitamin) / length(vitamin) [1] 92.776 Another example when we have highly distinctive observation.\n\n\nvitaminOutlirs <- c(vitamin, 320) mean(vitaminOutlirs) [1] 100.1058 As we see the mean is highly sensitive to distinctive observations.\n\nWe can have NA values in the sample. We handle them with na.rm=TRUE\n\nvitaminMissing <- vitamin vitaminMissing[c(3, 7, 21)] <- NA vitaminMissing [1] 91.66 92.34 NA 92.97 93.40 92.94 NA 92.39 93.74 91.77 92.09 92.99 [13] 93.13 92.73 92.81 93.39 93.29 93.03 93.13 92.08 NA 92.82 92.99 92.60 [25] 93.41 92.89 92.76 92.19 92.34 92.68 mean(vitaminMissing) [1] NA mean(vitaminMissing, na.rm = TRUE) [1] 92.76148 mean(vitaminMissing[-c(3, 7, 21)]) [1] 92.76148 mean(vitaminMissing[!is.na(vitaminMissing)]) [1] 92.76148 or we can calculate it using the formula, but in these case we need to subtract the number of the NA from the sample size.\n\n\nsum(vitaminMissing) [1] NA sum(vitaminMissing, na.rm = TRUE) [1] 2504.56 sum(vitaminMissing, na.rm = TRUE) / (length(vitaminMissing) - sum(is.na(vitaminMissing))) [1] 92.76148 Trimmed mean /Орязано средно/ It is useful when the data contains many highly distinctive observations.\n\n\nvitaminOutlirs <- c(vitaminOutlirs, 50, 405, 31) vitaminOutlirs [1] 91.66 92.34 92.69 92.97 93.40 92.94 92.76 92.39 93.74 91.77 [11] 92.09 92.99 93.13 92.73 92.81 93.39 93.29 93.03 93.13 92.08 [21] 93.27 92.82 92.99 92.60 93.41 92.89 92.76 92.19 92.34 92.68 [31] 320.00 50.00 405.00 31.00 length(vitaminOutlirs) [1] 34 Let’s trim off 117 (or 2 observations) from the top and the bottom and then take the average.\n\n\nmean(vitaminOutlirs) [1] 105.5671 mean(vitaminOutlirs, trim = 1/17) [1] 92.776 vitaminOutlirs <- sort(vitaminOutlirs) vitaminTrim <- vitaminOutlirs[-c(1, 2, 33, 34)]; vitaminTrim [1] 91.66 91.77 92.08 92.09 92.19 92.34 92.34 92.39 92.60 92.68 92.69 92.73 [13] 92.76 92.76 92.81 92.82 92.89 92.94 92.97 92.99 92.99 93.03 93.13 93.13 [25] 93.27 93.29 93.39 93.40 93.41 93.74 mean(vitaminTrim) [1] 92.776 If the number of observations to be trimmed is not integer, let’s say ⌊118⌋ (or 1 observation) from the top and the bottom and then take the average.\n\n\nlength(vitaminOutlirs) / 18 [1] 1.888889 mean(vitaminOutlirs, trim = 1/18) [1] 98.54 vitaminTrim2 <- vitaminOutlirs[-c(1, 34)]; vitaminTrim2 [1] 50.00 91.66 91.77 92.08 92.09 92.19 92.34 92.34 92.39 92.60 [11] 92.68 92.69 92.73 92.76 92.76 92.81 92.82 92.89 92.94 92.97 [21] 92.99 92.99 93.03 93.13 93.13 93.27 93.29 93.39 93.40 93.41 [31] 93.74 320.00 mean(vitaminTrim2) [1] 98.54 As we trim more and more, the value of the mean gets closer to the median which is when trim = 1/2.\n\nSample median /Извадкова медиана/ Me(X)=12(x(⌊(n+1)/2⌋)+x(⌈(n+1)/2⌉)) Sample median is the number from which half of the observations are less than or equal to the median and half of the observations are bigger than or equal to the median. There for it is called also empirical 0.5-quantile or Q2.\n\nmedian(vitamin) [1] 92.815 median(vitaminOutlirs) [1] 92.815 As we can see the median is not sensitive to highly distinctive data.\n\nAnother way to calculate the sample median is to sort the elements and then to use the above formula\n\nvitaminSort <- sort(vitamin) n <- length(vitamin) 1/2 * (vitaminSort[floor((n + 1) / 2)] + vitaminSort[ceiling((n + 1) / 2)]) [1] 92.815 We can handle NA in the data with na.rm=TRUE\n\n\nmedian(vitaminMissing) [1] NA median(vitaminMissing, na.rm = TRUE) [1] 92.82 Or\n\n\nt <- vitaminMissing[!is.na(vitaminMissing)] t <- sort(t) n <- length(t) 1/2 * (t[floor((n + 1) / 2)] + t[ceiling((n + 1) / 2)]) [1] 92.82 Sample mode /Извадкова мода/ Sample mode is the most probable value in the sample for a discrete data or the place where the histogram has a maxima for a continuous data.\n\n\nx <- c(10, 12, 10, 4, 7, 10, 0, 3, 10, 9, 7, 3, 5, 0, 12, 5, 7, 3, 7, 5, 10) For a discrete data we can take the frequency table /Честотна таблица/ with the function table. It presents how many times has an observation occurred in the sample.\n\n\nt <- table(x); t x 0 3 4 5 7 9 10 12 2 3 1 3 4 1 5 2 names(t[which.max(t)]) [1] “10” We can also sort the table, by the frequencies of the observations, so it is more easy to see the mode\n\n\nsort(table(x), decreasing = TRUE) x 10 7 3 5 0 12 4 9 5 4 3 3 2 2 1 1 The mode is not obligatory unique.\n\nFor a continuous data\n\nx <- c(10.5, 6.2, 10.4, 4.7, 7.3, 10.9, 0, 3.5, 7.3, 9.6, 7.1, 3.8, 5.3, 0.2, 12, 5.6, 7.8, 3.6, 7.2, 5.1, 8.3) We can slice the data using the cut function in equally long intervals.\n\n\nxGroup <- cut(x, breaks = c(0, 2, 4, 6, 8, 10, 12)) class(xGroup) [1] “factor” xGroup [1] (10,12] (6,8] (10,12] (4,6] (6,8] (10,12]  (2,4] (6,8]\n[10] (8,10] (6,8] (2,4] (4,6] (0,2] (10,12] (4,6] (6,8] (2,4]\n[19] (6,8] (4,6] (8,10] Levels: (0,2] (2,4] (4,6] (6,8] (8,10] (10,12] This function returns a factor variable in which every observation is presented as the interval it is in.\n\nWe calculate the frequency table and present the results on a plot.\n\ntable(xGroup) xGroup (0,2] (2,4] (4,6] (6,8] (8,10] (10,12] 1 3 4 6 2 4 barplot(table(xGroup))\n\nOne way to estimate the mode of continuous variable is Mo=L+fMo−fMo−12fMo−(fMo−1+fMo+1)w where: L is the left end of the interval with max frequency fMo−1 is the frequency of the interval before the interval with max frequency fMo is the frequency of the interval with max frequency fMo+1 is the frequency of the interval after the interval with max frequency w length of the interval with max frequency\nIn our example: L=6\nfMo−1=4\nfMo=6\nfMo+1=2\nw=8−6=2\nMo=6+6−42∗6−(4+2)∗2=6+212−6∗2=6+23≈6.67\nThere are a lot of options presented on how to estimate the mode in modeest package with the most likely value function mlv. Sample quantile /Извадкови квантили/ P-quantile is the number from which p∗100% of the observations are less than or equal to the p-quantile and (1−p)∗100% of the observations are bigger than or equal to the p-quantile.\n\np <- 0.35 quantile(vitamin, p) 35% 92.696 First quartile /Първи квартил/ The first quartile Q1 is the 0.25-quantile.\n\n\np <- 0.25 quantile(vitamin, p) 25% 92.4425 Third quartile /Трети квартил/ The third quartile Q3 is the 0.75-quantile.\n\n\np <- 0.75 quantile(vitamin, p) 75% 93.105 IQR /Между квартилен размах/ The inter quartile range (IQR) is the difference between the 3rd and 1st quartile IQR=Q3−Q1.\n\n\nIQR(vitamin) [1] 0.6625 quantile(vitamin, 0.75) - quantile(vitamin, 0.25) 75% 0.6625 Lower hinge The lower hinge HL is the median of the first half of the ordered observations.\n\n\nfivenum(vitamin)[2] [1] 92.39 Upper hinge The upper hinge HU is the median of the second half of the ordered observations.\n\n\nfivenum(vitamin)[4] [1] 93.13 Standard deviation /Стандартно отклонение/ σ=1n−1∑i=1n(xi−x¯)2−−−−−−−−−−−−−−−√ Sample standard deviation measures the deviation of the observations around their average.\n\n\nsd(vitamin) [1] 0.4992588 sd(vitaminOutlirs) [1] 67.2411 Sample variance /Извадкова дисперсия/ σ2=1n−1∑i=1n(xi−x¯)2 Sample variance is the second power of the standard deviation.\n\n\nvar(vitamin) [1] 0.2492593 var(vitaminOutlirs) [1] 4521.366 Differences x <- c(10, 3, 4, 7, 34, 23); x [1] 10 3 4 7 34 23 diff returns the first differences\n\n\ndiff(x) [1] -7 1 3 27 -11 with lag=2 returns the second differences\n\n\ndiff(x, lag = 2) [1] -6 4 30 16 Cummulative sums /Кумулативни суми/ cumsum returns the cumulative sums\n\n\ncumsum(x) [1] 10 13 17 24 58 81 Cummulative maximum /Кумулативни максимуми/ cummax returns the cumulative maximum\n\n\ncummax(x) [1] 10 10 10 10 34 34 Cummulative minimum /Кумулативни минимуми/ cummin returns the cumulative minimum\n\n\ncummin(x) [1] 10 3 3 3 3 3"
  },
  {
    "objectID": "text/basic_syntax.html",
    "href": "text/basic_syntax.html",
    "title": "The R programming language",
    "section": "",
    "text": "x + y   # Addition\nx - y   # Subtraction\nx * y   # Multiplication\nx / y   # Division\nx ^ y   # Raise to a power\nx ** y  # Raise to a power (old style /still not deprecated/ translated to ^ in the parser.)\nx %% y  # Modulus - remainder after the division\nx %/% y # Integer Division\n\nx, y: numeric or complex vectors or objects which can be coerced to such, or other objects for which methods have been written.\n\nFor documentation write ?Arithmetic in the R console:\n\n?Arithmetic\nhelp(\"Arithmetic\")\n\nUsing example we can run the examples in the end of the documentation:\n\nexample(\"Arithmetic\")\n## \n## Arthmt> x <- -1:12\n## \n## Arthmt> x + 1\n##  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13\n## \n## Arthmt> 2 * x + 3\n##  [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27\n## \n## Arthmt> x %% 2 #-- is periodic\n##  [1] 1 0 1 0 1 0 1 0 1 0 1 0 1 0\n## \n## Arthmt> x %/% 5\n##  [1] -1  0  0  0  0  0  1  1  1  1  1  2  2  2\n## \n## Arthmt> x %% Inf # now is defined by limit (gave NaN in earlier versions of R)\n##  [1] Inf   0   1   2   3   4   5   6   7   8   9  10  11  12\n\nUsing apropos we can look for similar function names:\n\napropos(\"sq\")\n## [1] \"chisq.test\" \"dchisq\"     \"pchisq\"     \"qchisq\"     \"rchisq\"    \n## [6] \"sqrt\"       \"sQuote\"\n\nUsing find we can find from which package is the function.\n\nfind(\"sqrt\")\n## [1] \"package:base\"\n\nWe can only search functions from the already loaded packages.\n\nfind(\"simple.lm\")\n## character(0)\nlibrary(UsingR)\n## Loading required package: MASS\n## Loading required package: HistData\n## Loading required package: Hmisc\n## Loading required package: lattice\n## Loading required package: survival\n## Loading required package: Formula\n## Loading required package: ggplot2\n## \n## Attaching package: 'Hmisc'\n## The following objects are masked from 'package:base':\n## \n##     format.pval, units\n## \n## Attaching package: 'UsingR'\n## The following object is masked from 'package:survival':\n## \n##     cancer\nfind(\"simple.lm\")\n## [1] \"package:UsingR\"\n\n\n\n\nFor documentation:\n\n?assignOps\n\nThere are 3 different assignment operators:\n\nx = 5\ny <- 5  # Recommended\n5 -> z\nx; y; z # Prints\n## [1] 5\n## [1] 5\n## [1] 5\n\nDifferences between them:\n\n\nThey have different operator precedence (look at ?Syntax).\n\n\n= has two meanings:\n\n<ul>\n        <li>operator: assignment operator</li>\n        <li>syntax token: named argument passing in a function call</li>\n    </ul>\n\n\nx = 20\nmean(x = 3); x\n## [1] 3\n## [1] 20\nmean(x <- 3); x # Not a good idea\n## [1] 3\n## [1] 3\n\n\n\n\n\nR is case sensitive\n\n\nA <- 5\na\n## Error in eval(expr, envir, enclos): object 'a' not found\n\n\nR is (dynamic language) not typified\n\n\na <- 5\na <- 5.4\na <- \"string\"\n\n\nValid names consist of letters, numbers and the dot or underline character.\n\n\n\n\n\nR can have default arguments and the arguments can be matched by position or by name.\n\n\n\n\nYou can print an object just by typing its name, because R is wrapping that object name within the print command, so the following lines of code are identical:\n\na\n## [1] \"string\"\nprint(a)\n## [1] \"string\"\n\nR uses the idea of generic functions, so print function looks for the attribute class of the object and the class type shows print how to generate the output.\nprint gives some options for formatting the output\n\nremoving the quotes from the output\n\n\nprint(a)\n## [1] \"string\"\nprint(a, quote = FALSE)\n## [1] string\n\n\ndetermine how many digits from the output to be shown\n\n\na <- 3145.429357453; a\n## [1] 3145.429\nprint(a, digits = 10)\n## [1] 3145.429357\n\nAlso we can redirect the output to a file using sink and then return it back to the console\n\nsink(\"myoutput.txt\")\n\n\n\n\ngetwd returns the absolute path to the current working directory.\n\ngetwd()\n## [1] \"/home/daniel/git/r/documentation/text\"\n\nThe working directory tells R where to look for files and where to create files. So the file that you have just created in the previous example myoutput.txt will be created in this directory.\nIf you want to change the working directory you can use setwd function\n\nsetwd(\"<path-to-directory>\")\n\n\n\n\nEverything in R is an object.\nls prints all names of the objects in the global environment\n\nls()\n\n[1] \"a\" \"A\" \"x\" \"y\" \"z\"\n\n\nrm removes objects from the current environment\n\nrm(x, y, z)\nls()\n\n[1] \"a\" \"A\"\n\n\nYou can also remove all the objects from the current environment using\nrm(list = ls())\nls()\ncharacter(0)\ncharacter(0)\ncharacter(0)\n\n\n\n\nComments start with #\nFor execution on Linux (in terminal): Rscript main.R"
  }
]